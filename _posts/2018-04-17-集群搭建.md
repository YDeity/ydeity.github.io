---
layout:     post
title:      集群间如何实现session共享
subtitle:   集群搭建
date:       2018-04-17
author:     YDeity
header-img: img/post-bg-coffee.jpeg
catalog: true
tags:
    - 分布式
    - 集群

---



引用至： http://mp.weixin.qq.com/s/9guDfd4phcYMx_JAhM9XwA

### 引言

针对企业，为了应对庞大的用户访问压力，目前大多数大型网站服务器都采用集群部署的方式；针对个人，仅一台服务器而言，也会安装多个tomcat进行错时更新，保证更新后台业务时服务不断开，即模拟了集群的运行方式。在此集群中，我们就不得不考虑一个用户鉴权的问题，即在不同服务上如何保证用户均已登录，并能获取相同的用户登录信息。



### Java Web推荐的（公认的）用户鉴权机制

说此部分之前先了解几个概念： 

1. 请求，即Request，指客户端向服务器发送的信息，通常是通信的发起方； 
2. 响应，即Response，指服务器对请求的应答，通常是通信的回复方； 
3. 会话，即Session，服务器可将请求<->响应这一个完整的过程称为一次会话，并为这次会话生成一个唯一的标识符，即sessionId，用来表示这次会话，Session储存在服务器端； 
4. Cookie，客户端保存在本地终端的数据，即Cookie储存在客户端。

Java Web的共用的用户鉴权机制是采用 Session-Cookie 技术，**实现原理**是：用户登录时，请求到达服务器，服务器调用通过 getSession() 方法判断 session 是否存在，如果不存在，则新建 session，并通过其算法为 session 生成一个随机数作为 sessionId，开发者可在 session 中储存一些用户信息；第二次请求时，如获取用户信息，getSession() 方法判断 session 存在，则取出 session，而不是新建，从而从session中获取到用户的相关信息。

客户端请求时，可以将 cookie 信息储存于 request 的 head 中发送给服务器； 
服务器响应时，可以将 cookie 信息置于 response 中回传给客户端。 



### 那么 getSession() 里究竟做了什么？

1. 第一次用户请求，客户端本地没有任何数据，即其 cookie 为空，朝服务器发送 request，getSession() 中会解析 request ,发现其约定的 cookie 为null，则认为没有 session，所以会重新创建一个 session 对象；
2. 创建 session 后会将此 session 的 id 放入 response 中，回传给客户端，客户端则保存 response 中的cookie；
3. 再次请求，服务器 getSession() 又会重新解析 request 获取 cookie，发现了其中的 sessionId，那么根据此sessionId 去服务器的中去找，则得到了上次创建的 session 对象，那么则认为鉴权成功。



### 集群间如何实现session共享

按照前文所说的 session-cookie 机制，session 是保存在每台服务器的，但在集群中，拥有多台服务器，每台各自为政，势必会造成在这台服务器中登录，获取 session 成功，但是到另一台服务器上，又会获取不到 session，造成鉴权失败，这样对用户来说是极不友好的，那么怎么解决这个问题呢？

通过我们以上的分析，即可得出几种处理方式: 

1. session 共享
   - 找一块公共的空间用来储存 session，而不是将 session 储存在集群节点的某台服务器上，此时，每一台服务器都能访问这块空间，从而实现 session 共享；
2. 同步 session
   - 仍在每台服务器上保存 session 信息，不作修改，但采用另一种同步机制，实时同步每一台服务器的 session信息；
3. 不采用 session-cookie 机制
   - 构建一种全新的鉴权机制，不采用 session-cookie 机制，但要去除此鉴权机制对单个服务器的依赖。



### 列举几种具体的实现方案：

1. 持久化 session 到数据库，即使用数据库来储存 session。数据库正好是我们普遍使用的公共储存空间，一举两得，推荐使用 mysql 数据库，轻量并且性能良好。
   - 优点：就地取材，符合大多数人的思维，使用简单，不需要太多额外编码工作 
   - 缺点：对 mysql 性能要求较高，访问 mysql 需要从连接池中获取连接，又因为大部分请求均需要进行登录鉴权，所以操作数据库非常频繁，当用户量达到一定程度之后，极易造成数据库瓶颈，不适用于处理高并发的情况。
2. 使用 redis 共享 session。redis 是一个 key-value 的储存系统。可以简单的将其理解为一个数据库，与传统数据库的区别是，它将数据储存于内存中，并自带有内存到硬盘的**序列化策略**，即按策略将内存中的数据同步到磁盘，避免数据丢失，是目前比较流行的解决方案。
   - 优点：无需增加数据库的压力，因为数据存储于内存中，所以读取非常快，高性能，并能处理多种类型的数据。 
   - 缺点：额外增加一些编码，以便操作 redis。
3. 使用 memcache 同步 session，memcache 可以实现分布式，可将**服务器中的内存组合起来**，形成一个“内存池”，以此充当公共空间，保存 session 信息。
   - 优点：数据储存在内存中，读取非常快，性能好； 
   - 缺点：memcache 把内存分成很多种规格的存储块，有大有小，不能完全利用内存，会产生内存碎片，浪费资源，如果储存块不足，还会产生内存溢出。
4. 通过脚本或守护进程在多台服务器之间同步 session。
   - 优点：实现了 session 共享； 
   - 缺点：对个人来说实现较为复杂，速度不稳定，有延时性，取决于现实中服务运行状态，偶然性较大，如果用于访问过快，可能出现session还没同步成功的情况。
5. 使用 NFS 共享 session。NFS 是 Network File Server 共享服务器的简称，最早由 Sun 公司为解决 Unix 网络主机间的目录共享而研发。选择一台公共的 NFS 做共享服务器，储存所有 session 数据，每台服务器所需的session 均从此处获取。
   - 优点：较好的实现了session共享； 
   - 缺点：成本较高，对于个人来说难以实现。NFS 依托于复杂的安全机制和文件系统，因此并发效率不高。
6. **使用 Cookie 共享 session**。此方案可以说是独辟蹊径了，将分布式思想用到了极致。如上文分析所说，session-cookie 机制中，session 与 cookie 相互关联，以 cookie 做中转站，用来找到对应的 session，其中session 存放在服务器。那么如果将 session 中的内容存放在 cookie 中呢？省略了服务器保存 session的过程，后台只需要根据 cookie 中约定的标识进行鉴权校验即可。
   - 优点：完美的贯彻分布式的理念，将每个用户都利用起来，无需耗费额外的服务器资源； 
   - 缺点：受 http 协议头长度限制，cookie 中存储的信息不宜过多；为了保持 cookie 全局有效，所以其一般依赖在根域名下，所以基本上所有的 http 请求都需要传递 cookie 中的这些标记信息，所以会占用一些服务器的带宽；鉴权信息全存储于 cookie 中，cookie 存在于客户端，服务器并没有储存相关信息，cookie 存在着泄露的可能，或则其他人揣摩出规则后可以进行伪装，其安全性比其他方案差，故需要对cookie 中信息进行加密解密，来增强其安全性。

